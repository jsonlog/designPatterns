<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Dec 06 22:07:03 EST 2000 -->
<TITLE>
bpwj: Class  Parser
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Parser.html"><FONT ID="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Building Parsers with Java</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../sjm/parse/Empty.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../sjm/parse/ParserTester.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
sjm.parse</FONT>
<BR>
Class  Parser</H2>
<PRE>
java.lang.Object
  |
  +--<B>sjm.parse.Parser</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../sjm/parse/CollectionParser.html">CollectionParser</A>, <A HREF="../../sjm/parse/Empty.html">Empty</A>, <A HREF="../../sjm/parse/Repetition.html">Repetition</A>, <A HREF="../../sjm/parse/Terminal.html">Terminal</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>Parser</B><DT>extends java.lang.Object</DL>

<P>
A <code>Parser</code> is an object that recognizes the 
 elements of a language.
 <p>
 Each <code>Parser</code> object is either a <code>
 Terminal</code> or a composition of other parsers. 
 The <code>Terminal</code> class is a subclass of <code>
 Parser</code>, and is itself a hierarchy of 
 parsers that recognize specific patterns of text. For 
 example, a <code>Word</code> recognizes any word, and a 
 <code>Literal</code> matches a specific string. 
 <p>
 In addition to <code>Terminal</code>, other subclasses of 
 <code>Parser</code> provide composite parsers, 
 describing sequences, alternations, and repetitions of 
 other parsers. For example, the following <code>
 Parser</code> objects culminate in a <code>good
 </code> parser that recognizes a description of good 
 coffee.

 <blockquote><pre>
     Alternation adjective = new Alternation();
     adjective.add(new Literal("steaming"));
     adjective.add(new Literal("hot"));
     Sequence good = new Sequence();
     good.add(new Repetition(adjective));
     good.add(new Literal("coffee"));
     String s = "hot hot steaming hot coffee";
     Assembly a = new TokenAssembly(s);
     System.out.println(good.bestMatch(a));
 </pre></blockquote>

 This prints out:

 <blockquote><pre>
     [hot, hot, steaming, hot, coffee]
     hot/hot/steaming/hot/coffee^
 </pre></blockquote>

 The parser does not match directly against a string, 
 it matches against an <code>Assembly</code>.  The 
 resulting assembly shows its stack, with four words on it, 
 along with its sequence of tokens, and the index at the 
 end of these. In practice, parsers will do some work 
 on an assembly, based on the text they recognize.
<P>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../sjm/parse/Assembler.html">Assembler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#assembler">assembler</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#name">name</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#Parser()">Parser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a nameless parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#Parser(java.lang.String)">Parser</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a parser with the given name.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#accept(sjm.parse.ParserVisitor)">accept</A></B>(<A HREF="../../sjm/parse/ParserVisitor.html">ParserVisitor</A>&nbsp;pv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accepts a "visitor" which will perform some operation on
 a parser structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#accept(sjm.parse.ParserVisitor, java.util.Vector)">accept</A></B>(<A HREF="../../sjm/parse/ParserVisitor.html">ParserVisitor</A>&nbsp;pv,
       java.util.Vector&nbsp;visited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accepts a "visitor" along with a collection of previously
 visited parsers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#add(java.util.Vector, java.util.Vector)">add</A></B>(java.util.Vector&nbsp;v1,
    java.util.Vector&nbsp;v2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the elements of one vector to another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sjm/parse/Assembly.html">Assembly</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#best(java.util.Vector)">best</A></B>(java.util.Vector&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the most-matched assembly in a collection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sjm/parse/Assembly.html">Assembly</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#bestMatch(sjm.parse.Assembly)">bestMatch</A></B>(<A HREF="../../sjm/parse/Assembly.html">Assembly</A>&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an assembly with the greatest possible number of 
 elements consumed by matches of this parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sjm/parse/Assembly.html">Assembly</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#completeMatch(sjm.parse.Assembly)">completeMatch</A></B>(<A HREF="../../sjm/parse/Assembly.html">Assembly</A>&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns either null, or a completely matched version of 
 the supplied assembly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Vector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#elementClone(java.util.Vector)">elementClone</A></B>(java.util.Vector&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a copy of a vector, cloning each element of
 the vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of this parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.util.Vector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#match(java.util.Vector)">match</A></B>(java.util.Vector&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a set (well, a <code>Vector</code>, really) of 
 assemblies, this method matches this parser against 
 all of them, and returns a new set (also really a 
 <code>Vector</code>) of the assemblies that result from 
 the matches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Vector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#matchAndAssemble(java.util.Vector)">matchAndAssemble</A></B>(java.util.Vector&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match this parser against an input state, and then
 apply this parser's assembler against the resulting
 state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;java.util.Vector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#randomExpansion(int, int)">randomExpansion</A></B>(int&nbsp;maxDepth,
                int&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#randomInput(int, java.lang.String)">randomInput</A></B>(int&nbsp;maxDepth,
            java.lang.String&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a random element of this parser's language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../sjm/parse/Parser.html">Parser</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#setAssembler(sjm.parse.Assembler)">setAssembler</A></B>(<A HREF="../../sjm/parse/Assembler.html">Assembler</A>&nbsp;assembler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object that will work on an assembly whenever 
 this parser successfully matches against the 
 assembly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a textual description of this parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#toString(java.util.Vector)">toString</A></B>(java.util.Vector&nbsp;visited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a textual description of this parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../sjm/parse/Parser.html#unvisitedString(java.util.Vector)">unvisitedString</A></B>(java.util.Vector&nbsp;visited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, 
equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="name"><!-- --></A><H3>
name</H3>
<PRE>
protected java.lang.String <B>name</B></PRE>
<DL>
</DL>
<HR>

<A NAME="assembler"><!-- --></A><H3>
assembler</H3>
<PRE>
protected <A HREF="../../sjm/parse/Assembler.html">Assembler</A> <B>assembler</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Parser()"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>()</PRE>
<DL>
<DD>Constructs a nameless parser.</DL>
<HR>

<A NAME="Parser(java.lang.String)"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Constructs a parser with the given name.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - A name to be known by. For parsers
                   that are deep composites, a simple name
                   identifying its purpose is useful.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="accept(sjm.parse.ParserVisitor)"><!-- --></A><H3>
accept</H3>
<PRE>
public void <B>accept</B>(<A HREF="../../sjm/parse/ParserVisitor.html">ParserVisitor</A>&nbsp;pv)</PRE>
<DL>
<DD>Accepts a "visitor" which will perform some operation on
 a parser structure. The book, "Design Patterns", explains
 the visitor pattern.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ParserVisitor</CODE> - the visitor to accept</DL>
</DD>
</DL>
<HR>

<A NAME="accept(sjm.parse.ParserVisitor, java.util.Vector)"><!-- --></A><H3>
accept</H3>
<PRE>
public abstract void <B>accept</B>(<A HREF="../../sjm/parse/ParserVisitor.html">ParserVisitor</A>&nbsp;pv,
                            java.util.Vector&nbsp;visited)</PRE>
<DL>
<DD>Accepts a "visitor" along with a collection of previously
 visited parsers.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ParserVisitor</CODE> - the visitor to accept<DD><CODE>Vector</CODE> - a collection of previously visited 
                   parsers.</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.util.Vector, java.util.Vector)"><!-- --></A><H3>
add</H3>
<PRE>
public static void <B>add</B>(java.util.Vector&nbsp;v1,
                       java.util.Vector&nbsp;v2)</PRE>
<DL>
<DD>Adds the elements of one vector to another.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v1</CODE> - the vector to add to<DD><CODE>v2</CODE> - the vector with elements to add</DL>
</DD>
</DL>
<HR>

<A NAME="best(java.util.Vector)"><!-- --></A><H3>
best</H3>
<PRE>
public <A HREF="../../sjm/parse/Assembly.html">Assembly</A> <B>best</B>(java.util.Vector&nbsp;v)</PRE>
<DL>
<DD>Returns the most-matched assembly in a collection.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Vector</CODE> - the collection to look through<DT><B>Returns:</B><DD>the most-matched assembly in a collection.</DL>
</DD>
</DL>
<HR>

<A NAME="bestMatch(sjm.parse.Assembly)"><!-- --></A><H3>
bestMatch</H3>
<PRE>
public <A HREF="../../sjm/parse/Assembly.html">Assembly</A> <B>bestMatch</B>(<A HREF="../../sjm/parse/Assembly.html">Assembly</A>&nbsp;a)</PRE>
<DL>
<DD>Returns an assembly with the greatest possible number of 
 elements consumed by matches of this parser.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Assembly</CODE> - an assembly to match against<DT><B>Returns:</B><DD>an assembly with the greatest possible number of 
           elements consumed by this parser</DL>
</DD>
</DL>
<HR>

<A NAME="completeMatch(sjm.parse.Assembly)"><!-- --></A><H3>
completeMatch</H3>
<PRE>
public <A HREF="../../sjm/parse/Assembly.html">Assembly</A> <B>completeMatch</B>(<A HREF="../../sjm/parse/Assembly.html">Assembly</A>&nbsp;a)</PRE>
<DL>
<DD>Returns either null, or a completely matched version of 
 the supplied assembly.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Assembly</CODE> - an assembly to match against<DT><B>Returns:</B><DD>either null, or a completely matched version of the
           supplied assembly</DL>
</DD>
</DL>
<HR>

<A NAME="elementClone(java.util.Vector)"><!-- --></A><H3>
elementClone</H3>
<PRE>
public static java.util.Vector <B>elementClone</B>(java.util.Vector&nbsp;v)</PRE>
<DL>
<DD>Create a copy of a vector, cloning each element of
 the vector.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - the vector to copy<DT><B>Returns:</B><DD>a copy of the input vector, cloning each 
           element of the vector</DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>()</PRE>
<DL>
<DD>Returns the name of this parser.<DD><DL>
<DT><B>Returns:</B><DD>the name of this parser</DL>
</DD>
</DL>
<HR>

<A NAME="match(java.util.Vector)"><!-- --></A><H3>
match</H3>
<PRE>
public abstract java.util.Vector <B>match</B>(java.util.Vector&nbsp;in)</PRE>
<DL>
<DD>Given a set (well, a <code>Vector</code>, really) of 
 assemblies, this method matches this parser against 
 all of them, and returns a new set (also really a 
 <code>Vector</code>) of the assemblies that result from 
 the matches.
 <p>
 For example, consider matching the regular expression 
 <code>a*</code> against the string <code>"aaab"</code>. 
 The initial set of states is <code>{^aaab}</code>, where 
 the ^ indicates how far along the assembly is. When 
 <code>a*</code> matches against this initial state, it 
 creates a new set <code>{^aaab, a^aab, aa^ab, 
 aaa^b}</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Vector</CODE> - a vector of assemblies to match against<DT><B>Returns:</B><DD>a Vector of assemblies that result from 
           matching against a beginning set of assemblies</DL>
</DD>
</DL>
<HR>

<A NAME="matchAndAssemble(java.util.Vector)"><!-- --></A><H3>
matchAndAssemble</H3>
<PRE>
public java.util.Vector <B>matchAndAssemble</B>(java.util.Vector&nbsp;in)</PRE>
<DL>
<DD>Match this parser against an input state, and then
 apply this parser's assembler against the resulting
 state.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Vector</CODE> - a vector of assemblies to match against<DT><B>Returns:</B><DD>a Vector of assemblies that result from matching
           against a beginning set of assemblies</DL>
</DD>
</DL>
<HR>

<A NAME="randomExpansion(int, int)"><!-- --></A><H3>
randomExpansion</H3>
<PRE>
protected abstract java.util.Vector <B>randomExpansion</B>(int&nbsp;maxDepth,
                                                    int&nbsp;depth)</PRE>
<DL>
</DL>
<HR>

<A NAME="randomInput(int, java.lang.String)"><!-- --></A><H3>
randomInput</H3>
<PRE>
public java.lang.String <B>randomInput</B>(int&nbsp;maxDepth,
                                    java.lang.String&nbsp;separator)</PRE>
<DL>
<DD>Return a random element of this parser's language.<DD><DL>
<DT><B>Returns:</B><DD>a random element of this parser's language</DL>
</DD>
</DL>
<HR>

<A NAME="setAssembler(sjm.parse.Assembler)"><!-- --></A><H3>
setAssembler</H3>
<PRE>
public <A HREF="../../sjm/parse/Parser.html">Parser</A> <B>setAssembler</B>(<A HREF="../../sjm/parse/Assembler.html">Assembler</A>&nbsp;assembler)</PRE>
<DL>
<DD>Sets the object that will work on an assembly whenever 
 this parser successfully matches against the 
 assembly.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Assembler</CODE> - the assembler to apply<DT><B>Returns:</B><DD>Parser   this</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a textual description of this parser.<DD><DL>
<DT><B>Overrides:</B><DD>toString in class java.lang.Object</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>String   a textual description of this 
                    parser, taking care to avoid 
                    infinite recursion</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.util.Vector)"><!-- --></A><H3>
toString</H3>
<PRE>
protected java.lang.String <B>toString</B>(java.util.Vector&nbsp;visited)</PRE>
<DL>
<DD>Returns a textual description of this parser.
 Parsers can be recursive, so when building a 
 descriptive string, it is important to avoid infinite 
 recursion by keeping track of the objects already 
 described. This method keeps an object from printing 
 twice, and uses <code>unvisitedString</code> which 
 subclasses must implement.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Vector</CODE> - a list of objects already printed<DT><B>Returns:</B><DD>a textual version of this parser,
           avoiding recursion</DL>
</DD>
</DL>
<HR>

<A NAME="unvisitedString(java.util.Vector)"><!-- --></A><H3>
unvisitedString</H3>
<PRE>
protected abstract java.lang.String <B>unvisitedString</B>(java.util.Vector&nbsp;visited)</PRE>
<DL>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Parser.html"><FONT ID="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
by Steve Metsker</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../sjm/parse/Empty.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../sjm/parse/ParserTester.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
